"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/loader/index.ts
var loader_exports = {};
__export(loader_exports, {
  default: () => loader
});
module.exports = __toCommonJS(loader_exports);
var import_node_path = __toESM(require("path"));
var import_fs_extra = __toESM(require("fs-extra"));
var import_constants = require("next/constants");
var import_config = __toESM(require("next/dist/server/config"));

// src/utils/getConfig.ts
var getConfig = () => {
  const config = require("next-export-optimize-images/export-images.config.js");
  return {
    ...config,
    filenameGenerator: config.filenameGenerator ? Function(`"use strict";return (${config.filenameGenerator})`)() : void 0,
    sourceImageParser: config.sourceImageParser ? Function(`"use strict";return (${config.sourceImageParser})`)() : void 0
  };
};
var getConfig_default = getConfig;

// src/utils/formatValidate.ts
var formats = ["jpeg", "jpg", "png", "webp", "avif"];
var formatValidate = (format) => formats.some((allowedFormat) => allowedFormat === format);
var formatValidate_default = formatValidate;

// src/utils/buildOutputInfo.ts
var defaultImageParser = (src) => {
  const path2 = src.split(/\.([^.]*$)/)[0];
  const extension = (src.split(/\.([^.]*$)/)[1] || "").split("?")[0];
  if (!path2 || !extension) {
    throw new Error(`Invalid path or no file extension: ${src}`);
  }
  let pathWithoutName = path2.split("/").slice(0, -1).join("/");
  const name = path2.split("/").slice(-1).toString();
  if (src.startsWith("http")) {
    pathWithoutName = pathWithoutName.replace(/^https?:\/\//, "").split("/").slice(1).join("/");
  }
  return {
    pathWithoutName,
    name,
    extension
  };
};
var buildOutputInfo = ({ src: _src, width, config }) => {
  let src = _src;
  if (config.basePath !== void 0) {
    src = _src.replace(config.basePath, "");
  }
  const parsedImageInformation = config.sourceImageParser ? config.sourceImageParser({ src, defaultParser: defaultImageParser }) : defaultImageParser(src);
  let { extension } = parsedImageInformation;
  const { pathWithoutName, name, extension: originalExtension } = parsedImageInformation;
  if (config.convertFormat !== void 0) {
    const convertArray = config.convertFormat.find(([beforeConvert]) => beforeConvert === extension);
    if (convertArray !== void 0) {
      if (!formatValidate_default(convertArray[0]))
        throw Error(`Unauthorized format specified in \`configFormat\`. beforeConvert: ${convertArray[0]}`);
      if (!formatValidate_default(convertArray[1]))
        throw Error(`Unauthorized format specified in \`configFormat\`. afterConvert: ${convertArray[1]}`);
      extension = convertArray[1];
    }
  }
  const outputDir = `/${config.imageDir ? config.imageDir.replace(/^\//, "").replace(/\/$/, "") : "_next/static/chunks/images"}`;
  const extensions = [.../* @__PURE__ */ new Set([...config.generateFormats ?? ["webp"], extension])];
  return extensions.map((extension2, index) => {
    if (extensions.length !== index + 1 && !formatValidate_default(extension2))
      throw Error(`Unauthorized extension specified in \`generateFormats\`: ${extension2}`);
    const filename = config.filenameGenerator !== void 0 ? config.filenameGenerator({ path: pathWithoutName, name, width, extension: extension2 }) : `${pathWithoutName}/${name}_${width}.${extension2}`;
    const output = `${outputDir}/${filename.replace(/^\//, "")}`;
    return { output, src, extension: extension2, originalExtension };
  });
};
var buildOutputInfo_default = buildOutputInfo;

// src/loader/index.ts
async function loader(content) {
  this.cacheable?.(false);
  const callback = this.async();
  const { dir, isDev } = this.getOptions();
  if (isDev) {
    callback(null, content);
    return;
  }
  const { src } = JSON.parse(content.replace(/^export default /, "").replace(/;$/, ""));
  const config = getConfig_default();
  const nextConfig = await (0, import_config.default)(import_constants.PHASE_PRODUCTION_BUILD, dir);
  const allSizes = [...nextConfig.images.deviceSizes, ...nextConfig.images.imageSizes];
  if (!src.endsWith(".svg")) {
    await Promise.all(
      allSizes.map(async (size) => {
        const outputInfo = buildOutputInfo_default({ src, width: size, config });
        for (const { output, src: src2, extension } of outputInfo) {
          const json = {
            output,
            src: src2,
            width: size,
            extension
          };
          await import_fs_extra.default.appendFile(
            import_node_path.default.join(process.cwd(), ".next/next-export-optimize-images-list.nd.json"),
            `${JSON.stringify(json)}
`
          );
        }
      })
    );
  }
  callback(null, content);
  return;
}
//# sourceMappingURL=loader.js.map