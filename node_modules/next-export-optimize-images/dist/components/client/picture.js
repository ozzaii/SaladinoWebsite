"use client";
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/components/client/picture.tsx
var picture_exports = {};
__export(picture_exports, {
  default: () => picture_default
});
module.exports = __toCommonJS(picture_exports);
var import_image = __toESM(require("next/image"));
var import_react = __toESM(require("react"));

// src/utils/getConfig.ts
var getConfig = () => {
  const config3 = require("next-export-optimize-images/export-images.config.js");
  return {
    ...config3,
    filenameGenerator: config3.filenameGenerator ? Function(`"use strict";return (${config3.filenameGenerator})`)() : void 0,
    sourceImageParser: config3.sourceImageParser ? Function(`"use strict";return (${config3.sourceImageParser})`)() : void 0
  };
};
var getConfig_default = getConfig;

// src/components/utils/getStringSrc.ts
var getStringSrc = (imgSrc) => {
  return typeof imgSrc === "string" ? imgSrc : imgSrc.default !== void 0 ? imgSrc.default.src : imgSrc.src;
};
var getStringSrc_default = getStringSrc;

// src/utils/formatValidate.ts
var formats = ["jpeg", "jpg", "png", "webp", "avif"];
var formatValidate = (format) => formats.some((allowedFormat) => allowedFormat === format);
var formatValidate_default = formatValidate;

// src/utils/buildOutputInfo.ts
var defaultImageParser = (src) => {
  const path = src.split(/\.([^.]*$)/)[0];
  const extension = (src.split(/\.([^.]*$)/)[1] || "").split("?")[0];
  if (!path || !extension) {
    throw new Error(`Invalid path or no file extension: ${src}`);
  }
  let pathWithoutName = path.split("/").slice(0, -1).join("/");
  const name = path.split("/").slice(-1).toString();
  if (src.startsWith("http")) {
    pathWithoutName = pathWithoutName.replace(/^https?:\/\//, "").split("/").slice(1).join("/");
  }
  return {
    pathWithoutName,
    name,
    extension
  };
};
var buildOutputInfo = ({ src: _src, width, config: config3 }) => {
  let src = _src;
  if (config3.basePath !== void 0) {
    src = _src.replace(config3.basePath, "");
  }
  const parsedImageInformation = config3.sourceImageParser ? config3.sourceImageParser({ src, defaultParser: defaultImageParser }) : defaultImageParser(src);
  let { extension } = parsedImageInformation;
  const { pathWithoutName, name, extension: originalExtension } = parsedImageInformation;
  if (config3.convertFormat !== void 0) {
    const convertArray = config3.convertFormat.find(([beforeConvert]) => beforeConvert === extension);
    if (convertArray !== void 0) {
      if (!formatValidate_default(convertArray[0]))
        throw Error(`Unauthorized format specified in \`configFormat\`. beforeConvert: ${convertArray[0]}`);
      if (!formatValidate_default(convertArray[1]))
        throw Error(`Unauthorized format specified in \`configFormat\`. afterConvert: ${convertArray[1]}`);
      extension = convertArray[1];
    }
  }
  const outputDir = `/${config3.imageDir ? config3.imageDir.replace(/^\//, "").replace(/\/$/, "") : "_next/static/chunks/images"}`;
  const extensions = [.../* @__PURE__ */ new Set([...config3.generateFormats ?? ["webp"], extension])];
  return extensions.map((extension2, index) => {
    if (extensions.length !== index + 1 && !formatValidate_default(extension2))
      throw Error(`Unauthorized extension specified in \`generateFormats\`: ${extension2}`);
    const filename = config3.filenameGenerator !== void 0 ? config3.filenameGenerator({ path: pathWithoutName, name, width, extension: extension2 }) : `${pathWithoutName}/${name}_${width}.${extension2}`;
    const output = `${outputDir}/${filename.replace(/^\//, "")}`;
    return { output, src, extension: extension2, originalExtension };
  });
};
var buildOutputInfo_default = buildOutputInfo;

// src/components/utils/imageLoader.ts
var config = getConfig_default();
var imageLoader = (getNumber) => ({ src, width }) => {
  if (process.env.NODE_ENV === "development") {
    return `${src}?width=${width}`;
  }
  const outputInfo = buildOutputInfo_default({ src, width, config }).at(getNumber ?? -1);
  if (outputInfo === void 0) {
    throw new Error(`No output info found for ${src}`);
  }
  return `${config.basePath ?? ""}${outputInfo.output}`;
};
var imageLoader_default = imageLoader;

// src/components/client/picture.tsx
var config2 = getConfig_default();
var Picture = (0, import_react.forwardRef)((props, forwardedRef) => {
  const srcStr = getStringSrc_default(props.src);
  if (srcStr.endsWith(".svg")) {
    return /* @__PURE__ */ import_react.default.createElement(import_image.default, { ...props, ref: forwardedRef, loader: props.loader || imageLoader_default(), unoptimized: true });
  }
  const blurDataURLObj = props.blurDataURL ? { blurDataURL: props.blurDataURL } : typeof props.src === "string" && props.placeholder === "blur" && props.loader === void 0 ? { blurDataURL: imageLoader_default()({ src: props.src, width: 8, quality: 10 }) } : {};
  const additionalFormats = [...new Set(config2.generateFormats ?? ["webp"])];
  const sources = additionalFormats.map((format, i) => {
    const sourceProps = (0, import_image.getImageProps)({
      ...props,
      loader: imageLoader_default(i)
    }).props;
    return {
      srcSet: sourceProps.srcSet,
      type: `image/${format}`,
      width: sourceProps.width,
      height: sourceProps.height,
      sizes: sourceProps.sizes
    };
  });
  return /* @__PURE__ */ import_react.default.createElement("picture", null, sources.map((source) => /* @__PURE__ */ import_react.default.createElement("source", { key: source.type, ...source })), /* @__PURE__ */ import_react.default.createElement(import_image.default, { ...props, ref: forwardedRef, loader: props.loader || imageLoader_default(), ...blurDataURLObj }));
});
Picture.displayName = "Picture";
var picture_default = Picture;
//# sourceMappingURL=picture.js.map