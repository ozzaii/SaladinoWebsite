{"version":3,"sources":["../src/cli/index.ts","../src/utils/formatValidate.ts","../src/utils/buildOutputInfo.ts","../src/utils/getConfig.ts","../src/utils/parseNdJSON.ts","../src/utils/processManifest.ts","../src/cli/external-images/index.ts","../src/cli/utils/cache.ts","../src/cli/utils/cliProgressBar.ts","../src/cli/utils/uniqueItems.ts"],"sourcesContent":["import { createHash } from 'node:crypto'\nimport path from 'node:path'\nimport colors from 'ansi-colors'\nimport fs from 'fs-extra'\nimport { PHASE_PRODUCTION_BUILD } from 'next/constants'\nimport loadConfig from 'next/dist/server/config'\nimport type { ImageConfigComplete } from 'next/dist/shared/lib/image-config'\nimport recursiveReadDir from 'recursive-readdir'\nimport sharp from 'sharp'\nimport buildOutputInfo from '../utils/buildOutputInfo'\nimport formatValidate from '../utils/formatValidate'\nimport getConfig, { type Config } from '../utils/getConfig'\nimport processManifest from '../utils/processManifest'\nimport externalImagesDownloader from './external-images'\nimport { type CacheImages, createCacheDir, defaultCacheDir, readCacheManifest, writeCacheManifest } from './utils/cache'\nimport { cliProgressBarIncrement, cliProgressBarStart } from './utils/cliProgressBar'\nimport uniqueItems from './utils/uniqueItems'\n\nexport type Manifest = {\n  output: string\n  src: string\n  width: number\n  extension: string\n  externalUrl?: string\n}[]\n\ntype GetOptimizeResultProps = {\n  imageBuffer: Buffer\n  destDir: string\n  noCache: boolean\n  cacheImages: CacheImages\n  cacheDir: string\n  cacheMeasurement: () => void\n  nonCacheMeasurement: () => void\n  errorMeasurement: () => void\n  pushInvalidFormatAssets: (asset: string) => void\n  cliProgressBarIncrement: () => void\n  originalFilePath: string\n  quality: number\n  sharpOptions?: Config['sharpOptions']\n} & Omit<Manifest[number], 'src'>\ntype GetOptimizeResult = (getOptimizeResultProps: GetOptimizeResultProps) => Promise<void>\n\nexport const getOptimizeResult: GetOptimizeResult = async ({\n  imageBuffer,\n  destDir,\n  noCache,\n  cacheImages,\n  cacheDir,\n  cacheMeasurement,\n  nonCacheMeasurement,\n  errorMeasurement,\n  pushInvalidFormatAssets,\n  cliProgressBarIncrement,\n  originalFilePath,\n  quality,\n  sharpOptions,\n  output,\n  width,\n  extension,\n}) => {\n  if (formatValidate(extension)) {\n    try {\n      const filePath = path.join(destDir, output)\n      await fs.ensureFile(filePath)\n\n      const outputPath = path.join(cacheDir, output)\n      await fs.ensureFile(outputPath)\n\n      // Cache process\n      if (!noCache) {\n        const cacheImagesFindIndex = cacheImages.findIndex((cacheImage) => cacheImage.output === output)\n        const hash = createHash('sha256').update(imageBuffer).digest('hex')\n\n        if (cacheImagesFindIndex === -1) {\n          cacheImages.push({ output, hash })\n        } else {\n          const currentCacheImage = cacheImages[cacheImagesFindIndex]\n          if (currentCacheImage?.hash === hash) {\n            await fs.copy(outputPath, filePath)\n            cacheMeasurement()\n            cliProgressBarIncrement()\n            return\n          }\n          if (currentCacheImage !== undefined) {\n            currentCacheImage.hash = hash\n          }\n        }\n      }\n\n      const image = sharp(imageBuffer, { sequentialRead: true, animated: true })\n\n      image.rotate().resize({ width, withoutEnlargement: true })\n\n      switch (extension) {\n        case 'jpeg': {\n          const jpeg = await image.jpeg({ quality, ...sharpOptions?.jpg })\n          await jpeg.toFile(outputPath)\n          await jpeg.toFile(filePath)\n          break\n        }\n        case 'jpg': {\n          const jpg = await image.jpeg({ quality, ...sharpOptions?.jpg })\n          await jpg.toFile(outputPath)\n          await jpg.toFile(filePath)\n          break\n        }\n        case 'png': {\n          const png = await image.png({ quality, ...sharpOptions?.png })\n          await png.toFile(outputPath)\n          await png.toFile(filePath)\n          break\n        }\n        case 'webp': {\n          const webp = image.webp({ quality, ...sharpOptions?.webp })\n          await webp.toFile(outputPath)\n          await webp.toFile(filePath)\n          break\n        }\n        case 'avif': {\n          const avif = image.avif({ quality, ...sharpOptions?.avif })\n          await avif.toFile(outputPath)\n          await avif.toFile(filePath)\n          break\n        }\n      }\n\n      nonCacheMeasurement()\n    } catch (error) {\n      console.warn(error)\n      errorMeasurement()\n    } finally {\n      cliProgressBarIncrement()\n    }\n  } else {\n    try {\n      const filePath = path.join(destDir, output)\n      await fs.ensureFile(filePath)\n\n      await fs.copy(originalFilePath, filePath)\n\n      extension !== 'svg' && pushInvalidFormatAssets(originalFilePath)\n    } catch (error) {\n      console.warn(error)\n      errorMeasurement()\n    } finally {\n      cliProgressBarIncrement()\n    }\n  }\n}\n\nconst cwd = process.cwd()\n\ntype OptimizeImagesProps = {\n  manifestJsonPath: string\n  noCache: boolean\n  config: Config\n  nextImageConfig: ImageConfigComplete\n  terse?: boolean\n}\n\nexport const optimizeImages = async ({\n  manifestJsonPath,\n  noCache,\n  config,\n  nextImageConfig,\n  terse = false,\n}: OptimizeImagesProps) => {\n  const destDir = config.mode === 'build' ? cwd : path.resolve(cwd, config.outDir ?? 'out')\n  const srcDir = config.mode === 'build' ? cwd : destDir\n\n  let manifest: Manifest = []\n  try {\n    if (fs.existsSync(manifestJsonPath)) {\n      manifest = uniqueItems(processManifest(await fs.readFile(manifestJsonPath, 'utf-8')))\n    }\n  } catch (error) {\n    throw Error(typeof error === 'string' ? error : 'Unexpected error.')\n  }\n\n  // Next Image allSizes\n  const allSizes = [...nextImageConfig.imageSizes, ...nextImageConfig.deviceSizes]\n\n  // External image if present\n  const remoteImages =\n    config.remoteImages === undefined\n      ? []\n      : typeof config.remoteImages === 'function'\n        ? await config.remoteImages()\n        : config.remoteImages\n  if (remoteImages.length > 0) {\n    const remoteImageList = new Set<string>()\n\n    for (const url of remoteImages) {\n      remoteImageList.add(url)\n    }\n\n    manifest = manifest.concat(\n      Array.from(remoteImageList)\n        .map((url) =>\n          allSizes.map((size) => {\n            return buildOutputInfo({\n              src: url,\n              width: size,\n              config,\n            }).map(({ output, extension, originalExtension }) => {\n              const externalOutputDir = `${\n                config.externalImageDir\n                  ? config.externalImageDir.replace(/^\\//, '').replace(/\\/$/, '')\n                  : '_next/static/media'\n              }`\n\n              const json: Manifest[number] = {\n                output,\n                src: `/${config.mode === 'build' ? externalOutputDir.replace(/^_next/, '.next') : externalOutputDir}/${createHash(\n                  'sha256'\n                )\n                  .update(\n                    url\n                      .replace(/^https?:\\/\\//, '')\n                      .split('/')\n                      .slice(1)\n                      .join('/')\n                  )\n                  .digest('hex')}.${originalExtension}`,\n                width: size,\n                extension,\n                externalUrl: url,\n              }\n\n              return json\n            })\n          })\n        )\n        .flat(2)\n    )\n  }\n  if (manifest.some(({ externalUrl }) => externalUrl !== undefined)) {\n    await externalImagesDownloader({\n      terse,\n      manifest,\n      destDir,\n      remoteImagesDownloadsDelay: config.remoteImagesDownloadsDelay,\n    })\n  }\n\n  const publicDir = path.resolve(cwd, 'public')\n  if (fs.existsSync(publicDir)) {\n    if (!terse) {\n      console.log('\\n- Collect images in public directory -')\n    }\n    const ignorePaths = config.ignorePaths ? config.ignorePaths.map((p) => path.join(publicDir, p)) : []\n\n    const publicDirFiles = await recursiveReadDir(publicDir)\n    const publicDirImages = publicDirFiles\n      .filter((file) => {\n        const ext = path.extname(file).toLowerCase()\n        return (\n          ext === '.png' || ext === '.jpg' || ext === '.jpeg' || ext === '.webp' || ext === '.avif' || ext === '.gif'\n        )\n      })\n      .filter((file) => !ignorePaths.includes(file))\n    manifest = manifest.concat(\n      publicDirImages\n        .map((file) =>\n          allSizes.map((size) => {\n            const ignorePath = config.mode === 'build' ? publicDir.replace(/public$/, '') : publicDir // The public directory in the root is required when building.\n            const src = file.replace(ignorePath, '')\n            return buildOutputInfo({\n              src,\n              width: size,\n              config,\n            }).map(({ output, extension }) => {\n              const json: Manifest[number] = {\n                output,\n                src,\n                width: size,\n                extension,\n              }\n\n              return json\n            })\n          })\n        )\n        .flat(2)\n    )\n  }\n\n  if (!terse) {\n    console.log('\\n- Image Optimization -')\n    cliProgressBarStart(manifest.length)\n  }\n\n  let cacheImages: CacheImages = []\n\n  if (!noCache) {\n    await createCacheDir()\n    cacheImages = readCacheManifest()\n  }\n\n  let measuredCache = 0\n  let measuredNonCache = 0\n  let measuredError = 0\n  const invalidFormatAssets = new Set<string>([])\n\n  const cacheMeasurement = () => {\n    measuredCache += 1\n  }\n  const nonCacheMeasurement = () => {\n    measuredNonCache += 1\n  }\n  const errorMeasurement = () => {\n    measuredError += 1\n  }\n  const pushInvalidFormatAssets = (asset: string) => invalidFormatAssets.add(asset)\n\n  const srcMap: Record<string, Omit<Manifest[number], 'src'>[]> = {}\n  for (const item of manifest) {\n    const { src, ...rest } = item\n    if (src in srcMap) {\n      srcMap[src]?.push(rest)\n    } else {\n      srcMap[src] = [rest]\n    }\n  }\n\n  const promises: Promise<void>[] = []\n\n  for (const key in srcMap) {\n    const items = srcMap[key]\n\n    if (items === undefined || items.length === 0) continue\n\n    const originalFilePath = path.join(srcDir, config.mode === 'build' ? key.replace(/^\\/_next/, '/.next') : key)\n    const imageBuffer = await fs.readFile(originalFilePath)\n\n    for (const item of items) {\n      item.output = config.mode === 'build' ? item.output.replace(/^\\/_next/, '/.next') : item.output\n\n      promises.push(\n        getOptimizeResult({\n          imageBuffer,\n          destDir,\n          noCache,\n          cacheImages,\n          cacheDir: defaultCacheDir,\n          cacheMeasurement,\n          nonCacheMeasurement,\n          errorMeasurement,\n          pushInvalidFormatAssets,\n          cliProgressBarIncrement: terse ? () => undefined : cliProgressBarIncrement,\n          originalFilePath,\n          quality: config.quality ?? 75,\n          sharpOptions: config.sharpOptions ?? {},\n          ...item,\n        })\n      )\n    }\n  }\n\n  await Promise.all(promises)\n\n  if (!noCache) {\n    writeCacheManifest(cacheImages)\n  }\n\n  if (!terse) {\n    // eslint-disable-next-line no-console\n    console.log(`Cache assets: ${measuredCache}, NonCache assets: ${measuredNonCache}, Error assets: ${measuredError}`)\n\n    if (invalidFormatAssets.size !== 0) {\n      // eslint-disable-next-line no-console\n      console.log(\n        '\\nThe following images are in a non-optimized format and a simple copy was applied.\\n',\n        Array.from(invalidFormatAssets).join('\\n')\n      )\n    }\n\n    console.log(colors.bold.magenta('\\nSuccessful optimization!'))\n  }\n}\n\ntype Run = (args: { noCache?: boolean }) => void\n\nexport const run: Run = async ({ noCache = false }) => {\n  // eslint-disable-next-line no-console\n  console.log(colors.bold.magenta('\\nnext-export-optimize-images: Optimize images.'))\n\n  const config = getConfig()\n  const manifestJsonPath = path.resolve(cwd, '.next/next-export-optimize-images-list.nd.json')\n\n  const nextConfig = await loadConfig(PHASE_PRODUCTION_BUILD, cwd)\n\n  await optimizeImages({ manifestJsonPath, noCache, config, nextImageConfig: nextConfig.images })\n}\n","const formats = ['jpeg', 'jpg', 'png', 'webp', 'avif'] as const\nexport type AllowedFormat = (typeof formats)[number]\n\nconst formatValidate = (format?: string): format is AllowedFormat =>\n  formats.some((allowedFormat) => allowedFormat === format)\n\nexport default formatValidate\n","import formatValidate from './formatValidate'\nimport type { Config, DefaultImageParser } from './getConfig'\n\nexport const defaultImageParser: DefaultImageParser = (src: string) => {\n  const path = src.split(/\\.([^.]*$)/)[0]\n  const extension = (src.split(/\\.([^.]*$)/)[1] || '').split('?')[0]\n\n  if (!path || !extension) {\n    throw new Error(`Invalid path or no file extension: ${src}`)\n  }\n\n  let pathWithoutName = path.split('/').slice(0, -1).join('/')\n  const name = path.split('/').slice(-1).toString()\n\n  if (src.startsWith('http')) {\n    pathWithoutName = pathWithoutName\n      .replace(/^https?:\\/\\//, '')\n      .split('/')\n      .slice(1)\n      .join('/')\n  }\n\n  return {\n    pathWithoutName,\n    name,\n    extension,\n  }\n}\n\ntype BuildOutputInfoArgs = {\n  src: string\n  width: number\n  config: Config\n}\n\nconst buildOutputInfo = ({ src: _src, width, config }: BuildOutputInfoArgs) => {\n  let src = _src\n\n  if (config.basePath !== undefined) {\n    src = _src.replace(config.basePath, '')\n  }\n\n  const parsedImageInformation = config.sourceImageParser\n    ? config.sourceImageParser({ src, defaultParser: defaultImageParser })\n    : defaultImageParser(src)\n\n  let { extension } = parsedImageInformation\n  const { pathWithoutName, name, extension: originalExtension } = parsedImageInformation\n\n  if (config.convertFormat !== undefined) {\n    const convertArray = config.convertFormat.find(([beforeConvert]) => beforeConvert === extension)\n    if (convertArray !== undefined) {\n      if (!formatValidate(convertArray[0]))\n        throw Error(`Unauthorized format specified in \\`configFormat\\`. beforeConvert: ${convertArray[0]}`)\n      if (!formatValidate(convertArray[1]))\n        throw Error(`Unauthorized format specified in \\`configFormat\\`. afterConvert: ${convertArray[1]}`)\n\n      extension = convertArray[1]\n    }\n  }\n\n  const outputDir = `/${\n    config.imageDir ? config.imageDir.replace(/^\\//, '').replace(/\\/$/, '') : '_next/static/chunks/images'\n  }`\n\n  const extensions = [...new Set([...(config.generateFormats ?? ['webp']), extension])]\n  return extensions.map((extension, index) => {\n    if (extensions.length !== index + 1 && !formatValidate(extension))\n      throw Error(`Unauthorized extension specified in \\`generateFormats\\`: ${extension}`)\n\n    const filename =\n      config.filenameGenerator !== undefined\n        ? config.filenameGenerator({ path: pathWithoutName, name, width, extension })\n        : `${pathWithoutName}/${name}_${width}.${extension}`\n    const output = `${outputDir}/${filename.replace(/^\\//, '')}`\n\n    return { output, src, extension, originalExtension }\n  })\n}\n\nexport default buildOutputInfo\n","import type { AvifOptions, JpegOptions, PngOptions, WebpOptions } from 'sharp'\nimport type { AllowedFormat } from './formatValidate'\n\ntype ParsedImageInfo = {\n  pathWithoutName: string\n  name: string\n  extension: string\n}\nexport type DefaultImageParser = (src: string) => ParsedImageInfo\ntype SourceImageParser = (determinerProps: { src: string; defaultParser: DefaultImageParser }) => ParsedImageInfo\n\nexport type Config = {\n  /**\n   * Specify if you are customizing the default output directory, such as next export -o outDir.\n   *\n   * @type {string}\n   */\n  outDir?: string\n  /**\n   * You can customize the directory to output optimized images.\n   * The default is '_next/static/chunks/images'.\n   *\n   * @type {string}\n   */\n  imageDir?: string\n  /**\n   * You can customize the directory to cache images.\n   * The default is 'node_modules/.cache'.\n   *\n   * @type {string}\n   */\n  cacheDir?: string\n  /**\n   * Images in the public directory are automatically optimized, but if there are any images you want to ignore the optimization for, please specify the path.\n   * Please specify a relative path from the public directory.\n   */\n  ignorePaths?: string[]\n  /**\n   * Required if you have set basePath in next.config.js.\n   * Please set the same value.\n   *\n   * @type {string}\n   */\n  basePath?: string\n  /**\n   * You can customize the directory to output downloaded external images.\n   * The default is '_next/static/media'\n   *\n   * @type {string}\n   */\n  externalImageDir?: string\n  /**\n   * You can customize the quality of the optimized image.\n   * The default is 75.\n   */\n  quality?: number\n  /**\n   * You can customize the generation of file names.\n   *\n   * ❗️Attention\n   * When making this setting, make sure that the file names (including the path part) of different images do not cover each other.\n   * Specifically, include the name, width, and extension in the return value. If path is not included, all src's should be specified with import or require so that they can be distinguished by their hash value even if they have the same filename.\n   *\n   * @type {({ path: string, name: string, width: number, extension: string }) => string}\n   */\n  filenameGenerator?: (generatorProps: { path: string; name: string; width: number; extension: string }) => string\n  /**\n   * You can set optimization options for each extension.\n   * Please refer to the official sharp documentation for more information.\n   *\n   * @type {{ png?: PngOptions, jpg?: JpegOptions, webp?: WebpOptions, avif?: AvifOptions } }}\n   */\n  sharpOptions?: {\n    png?: PngOptions\n    jpg?: JpegOptions\n    webp?: WebpOptions\n    avif?: AvifOptions\n  }\n  /**\n   * It allows you to convert images from any extension to another extension.\n   *\n   * @type {[beforeConvert: AllowedFormat, afterConvert: AllowedFormat][]}\n   */\n  convertFormat?: [beforeConvert: AllowedFormat, afterConvert: AllowedFormat][]\n\n  /**\n   * You can generate extra images in extensions specified.\n   * The default is ['webp'].\n   * This setting affects the extension displayed in the `Picture` component.\n   * The order is also important. For example, if `webp` is first, then `webp` will be displayed first.\n   *\n   * @type {('webp' | 'avif')[]}\n   */\n  generateFormats?: ('webp' | 'avif')[]\n\n  /**\n   * Allows you to optionally override the parsed image information before optimized images.\n   *\n   * @type {SourceImageParser}\n   */\n  sourceImageParser?: SourceImageParser\n\n  /**\n   * You can directly specify the URL of an external image.\n   * This is useful in cases where it is not known what images will be used for the build using variables, for example.\n   *\n   * @type {string[] | (() => string[] | Promise<string[]>)}\n   */\n  remoteImages?: string[] | (() => string[] | Promise<string[]>)\n\n  /**\n   * In case you need to download a large amount of images from an external CDN with a rate limit, this will add delays between downloading images.\n   */\n  remoteImagesDownloadsDelay?: number\n\n  /**\n   * You can specify the mode to use. The default is 'export'.\n   * 'build' mode is for use with `next build` and `next start`.\n   *\n   * @type {('build' | 'export')}\n   */\n  mode?: 'build' | 'export'\n}\n\ntype ResolvedConfig = Config & {\n  remoteImages?: string[]\n}\n\nconst getConfig = (): ResolvedConfig => {\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const config = require('next-export-optimize-images/export-images.config.js') as Omit<\n    ResolvedConfig,\n    'filenameGenerator' | 'sourceImageParser'\n  > & {\n    filenameGenerator?: string\n    sourceImageParser?: string\n  }\n\n  return {\n    ...config,\n    filenameGenerator: config.filenameGenerator\n      ? Function(`\"use strict\";return (${config.filenameGenerator})`)()\n      : undefined,\n    sourceImageParser: config.sourceImageParser\n      ? Function(`\"use strict\";return (${config.sourceImageParser})`)()\n      : undefined,\n  }\n}\n\nexport default getConfig\n","const parseNdJSON = (ndjson: string) =>\n  ndjson\n    .trim()\n    .split(/\\n/g)\n    .map((line) => JSON.parse(line))\n\nexport default parseNdJSON\n","import type { Manifest } from '../cli'\nimport parseNdJSON from './parseNdJSON'\n\nconst processManifest = (manifestJson: string): Manifest => parseNdJSON(manifestJson)\n\nexport default processManifest\n","import path from 'node:path'\nimport { Stream } from 'node:stream'\nimport type { ReadableStream } from 'node:stream/web'\nimport fs from 'fs-extra'\nimport type { Manifest } from '../'\nimport type { Config } from './../../utils/getConfig'\n\ntype ExternalImagesDownloaderArgs = {\n  terse?: boolean\n  manifest: Manifest\n  destDir: string\n  remoteImagesDownloadsDelay?: Config['remoteImagesDownloadsDelay']\n}\n\nconst sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms))\n\nconst externalImagesDownloader = async ({\n  terse = false,\n  manifest,\n  destDir,\n  remoteImagesDownloadsDelay,\n}: ExternalImagesDownloaderArgs) => {\n  if (!terse) {\n    // eslint-disable-next-line no-console\n    console.log('\\n- Download external images -')\n  }\n\n  const promises: Promise<void>[] = []\n  const downloadedImages: string[] = []\n\n  for (const { src, externalUrl } of manifest) {\n    if (externalUrl === undefined) continue\n\n    if (downloadedImages.some((image) => image === externalUrl)) continue\n\n    if (remoteImagesDownloadsDelay) {\n      await sleep(remoteImagesDownloadsDelay)\n    }\n\n    promises.push(\n      (async (): Promise<void> => {\n        downloadedImages.push(externalUrl)\n\n        const outputPath = path.join(destDir, src)\n        await fs.ensureFile(outputPath)\n\n        const body = await fetch(externalUrl)\n          .then((response) => response.body)\n          .catch((e) => {\n            throw new Error(`Failed to download \\`${externalUrl}\\`: ${e}`)\n          })\n\n        if (body === null) {\n          throw new Error(`Failed to download \\`${externalUrl}\\`: reason: body is null`)\n        }\n\n        const readableNodeStream = Stream.Readable.fromWeb(body as ReadableStream<Uint8Array>)\n        const fileStream = fs.createWriteStream(outputPath)\n\n        return new Promise((resolve, reject) => {\n          readableNodeStream.pipe(fileStream)\n          readableNodeStream.on('error', reject)\n          fileStream.on('finish', () => {\n            if (!terse) {\n              // eslint-disable-next-line no-console\n              console.log(`\\`${externalUrl}\\` has been downloaded.`)\n            }\n            resolve()\n          })\n        })\n      })()\n    )\n  }\n\n  await Promise.all(promises)\n}\n\nexport default externalImagesDownloader\n","import path from 'node:path'\n\nimport fs from 'fs-extra'\n\nimport getConfig from '../../utils/getConfig'\n\nconst cacheDir = getConfig().cacheDir || 'node_modules/.cache/next-export-optimize-images'\n\nexport const defaultCacheDir = cacheDir.startsWith('/') ? cacheDir : path.join(process.cwd(), cacheDir)\nexport const defaultCacheFilePath = path.join(defaultCacheDir, 'cached-images.json')\n\nexport const createCacheDir = async (cacheDir = defaultCacheDir) => {\n  await fs.mkdirp(cacheDir)\n}\n\nexport type CacheImages = {\n  output: string\n  hash: string\n}[]\n\nexport const readCacheManifest = (filePath = defaultCacheFilePath): CacheImages => {\n  try {\n    return JSON.parse(fs.readFileSync(filePath, 'utf-8'))\n  } catch (_) {\n    return []\n  }\n}\n\nexport const writeCacheManifest = (cacheImages: CacheImages, filePath = defaultCacheFilePath) => {\n  fs.writeFileSync(filePath, JSON.stringify(cacheImages), 'utf-8')\n}\n","import colors from 'ansi-colors'\nimport cliProgress from 'cli-progress'\n\nconst bar = new cliProgress.SingleBar({\n  format: `Optimization progress |${colors.cyan('{bar}')}| {percentage}% || {value}/{total} Chunks`,\n  barCompleteChar: '\\u2588',\n  barIncompleteChar: '\\u2591',\n  hideCursor: true,\n  stopOnComplete: true,\n})\n\nexport const cliProgressBarStart = (total: number) => {\n  bar.start(total, 0)\n}\n\nexport const cliProgressBarIncrement = (addNumber?: number) => {\n  bar.increment(addNumber)\n}\n","import uniqWith from 'lodash.uniqwith'\n\nimport type { Manifest } from '../'\n\nconst uniqueItems = (items: Manifest) =>\n  uniqWith(items, (a, b) => a.output === b.output && a.width === b.width && a.extension === b.extension)\n\nexport default uniqueItems\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBAA2B;AAC3B,IAAAA,oBAAiB;AACjB,IAAAC,sBAAmB;AACnB,IAAAC,mBAAe;AACf,uBAAuC;AACvC,oBAAuB;AAEvB,+BAA6B;AAC7B,mBAAkB;;;ACRlB,IAAM,UAAU,CAAC,QAAQ,OAAO,OAAO,QAAQ,MAAM;AAGrD,IAAM,iBAAiB,CAAC,WACtB,QAAQ,KAAK,CAAC,kBAAkB,kBAAkB,MAAM;AAE1D,IAAO,yBAAQ;;;ACHR,IAAM,qBAAyC,CAAC,QAAgB;AACrE,QAAMC,QAAO,IAAI,MAAM,YAAY,EAAE,CAAC;AACtC,QAAM,aAAa,IAAI,MAAM,YAAY,EAAE,CAAC,KAAK,IAAI,MAAM,GAAG,EAAE,CAAC;AAEjE,MAAI,CAACA,SAAQ,CAAC,WAAW;AACvB,UAAM,IAAI,MAAM,sCAAsC,GAAG,EAAE;AAAA,EAC7D;AAEA,MAAI,kBAAkBA,MAAK,MAAM,GAAG,EAAE,MAAM,GAAG,EAAE,EAAE,KAAK,GAAG;AAC3D,QAAM,OAAOA,MAAK,MAAM,GAAG,EAAE,MAAM,EAAE,EAAE,SAAS;AAEhD,MAAI,IAAI,WAAW,MAAM,GAAG;AAC1B,sBAAkB,gBACf,QAAQ,gBAAgB,EAAE,EAC1B,MAAM,GAAG,EACT,MAAM,CAAC,EACP,KAAK,GAAG;AAAA,EACb;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAQA,IAAM,kBAAkB,CAAC,EAAE,KAAK,MAAM,OAAO,OAAO,MAA2B;AAC7E,MAAI,MAAM;AAEV,MAAI,OAAO,aAAa,QAAW;AACjC,UAAM,KAAK,QAAQ,OAAO,UAAU,EAAE;AAAA,EACxC;AAEA,QAAM,yBAAyB,OAAO,oBAClC,OAAO,kBAAkB,EAAE,KAAK,eAAe,mBAAmB,CAAC,IACnE,mBAAmB,GAAG;AAE1B,MAAI,EAAE,UAAU,IAAI;AACpB,QAAM,EAAE,iBAAiB,MAAM,WAAW,kBAAkB,IAAI;AAEhE,MAAI,OAAO,kBAAkB,QAAW;AACtC,UAAM,eAAe,OAAO,cAAc,KAAK,CAAC,CAAC,aAAa,MAAM,kBAAkB,SAAS;AAC/F,QAAI,iBAAiB,QAAW;AAC9B,UAAI,CAAC,uBAAe,aAAa,CAAC,CAAC;AACjC,cAAM,MAAM,qEAAqE,aAAa,CAAC,CAAC,EAAE;AACpG,UAAI,CAAC,uBAAe,aAAa,CAAC,CAAC;AACjC,cAAM,MAAM,oEAAoE,aAAa,CAAC,CAAC,EAAE;AAEnG,kBAAY,aAAa,CAAC;AAAA,IAC5B;AAAA,EACF;AAEA,QAAM,YAAY,IAChB,OAAO,WAAW,OAAO,SAAS,QAAQ,OAAO,EAAE,EAAE,QAAQ,OAAO,EAAE,IAAI,4BAC5E;AAEA,QAAM,aAAa,CAAC,GAAG,oBAAI,IAAI,CAAC,GAAI,OAAO,mBAAmB,CAAC,MAAM,GAAI,SAAS,CAAC,CAAC;AACpF,SAAO,WAAW,IAAI,CAACC,YAAW,UAAU;AAC1C,QAAI,WAAW,WAAW,QAAQ,KAAK,CAAC,uBAAeA,UAAS;AAC9D,YAAM,MAAM,4DAA4DA,UAAS,EAAE;AAErF,UAAM,WACJ,OAAO,sBAAsB,SACzB,OAAO,kBAAkB,EAAE,MAAM,iBAAiB,MAAM,OAAO,WAAAA,WAAU,CAAC,IAC1E,GAAG,eAAe,IAAI,IAAI,IAAI,KAAK,IAAIA,UAAS;AACtD,UAAM,SAAS,GAAG,SAAS,IAAI,SAAS,QAAQ,OAAO,EAAE,CAAC;AAE1D,WAAO,EAAE,QAAQ,KAAK,WAAAA,YAAW,kBAAkB;AAAA,EACrD,CAAC;AACH;AAEA,IAAO,0BAAQ;;;ACgDf,IAAM,YAAY,MAAsB;AAEtC,QAAM,SAAS,QAAQ,qDAAqD;AAQ5E,SAAO;AAAA,IACL,GAAG;AAAA,IACH,mBAAmB,OAAO,oBACtB,SAAS,wBAAwB,OAAO,iBAAiB,GAAG,EAAE,IAC9D;AAAA,IACJ,mBAAmB,OAAO,oBACtB,SAAS,wBAAwB,OAAO,iBAAiB,GAAG,EAAE,IAC9D;AAAA,EACN;AACF;AAEA,IAAO,oBAAQ;;;ACrJf,IAAM,cAAc,CAAC,WACnB,OACG,KAAK,EACL,MAAM,KAAK,EACX,IAAI,CAAC,SAAS,KAAK,MAAM,IAAI,CAAC;AAEnC,IAAO,sBAAQ;;;ACHf,IAAM,kBAAkB,CAAC,iBAAmC,oBAAY,YAAY;AAEpF,IAAO,0BAAQ;;;ACLf,uBAAiB;AACjB,yBAAuB;AAEvB,sBAAe;AAWf,IAAM,QAAQ,CAAC,OAAe,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,EAAE,CAAC;AAE9E,IAAM,2BAA2B,OAAO;AAAA,EACtC,QAAQ;AAAA,EACR;AAAA,EACA;AAAA,EACA;AACF,MAAoC;AAClC,MAAI,CAAC,OAAO;AAEV,YAAQ,IAAI,gCAAgC;AAAA,EAC9C;AAEA,QAAM,WAA4B,CAAC;AACnC,QAAM,mBAA6B,CAAC;AAEpC,aAAW,EAAE,KAAK,YAAY,KAAK,UAAU;AAC3C,QAAI,gBAAgB,OAAW;AAE/B,QAAI,iBAAiB,KAAK,CAAC,UAAU,UAAU,WAAW,EAAG;AAE7D,QAAI,4BAA4B;AAC9B,YAAM,MAAM,0BAA0B;AAAA,IACxC;AAEA,aAAS;AAAA,OACN,YAA2B;AAC1B,yBAAiB,KAAK,WAAW;AAEjC,cAAM,aAAa,iBAAAC,QAAK,KAAK,SAAS,GAAG;AACzC,cAAM,gBAAAC,QAAG,WAAW,UAAU;AAE9B,cAAM,OAAO,MAAM,MAAM,WAAW,EACjC,KAAK,CAAC,aAAa,SAAS,IAAI,EAChC,MAAM,CAAC,MAAM;AACZ,gBAAM,IAAI,MAAM,wBAAwB,WAAW,OAAO,CAAC,EAAE;AAAA,QAC/D,CAAC;AAEH,YAAI,SAAS,MAAM;AACjB,gBAAM,IAAI,MAAM,wBAAwB,WAAW,0BAA0B;AAAA,QAC/E;AAEA,cAAM,qBAAqB,0BAAO,SAAS,QAAQ,IAAkC;AACrF,cAAM,aAAa,gBAAAA,QAAG,kBAAkB,UAAU;AAElD,eAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,6BAAmB,KAAK,UAAU;AAClC,6BAAmB,GAAG,SAAS,MAAM;AACrC,qBAAW,GAAG,UAAU,MAAM;AAC5B,gBAAI,CAAC,OAAO;AAEV,sBAAQ,IAAI,KAAK,WAAW,yBAAyB;AAAA,YACvD;AACA,oBAAQ;AAAA,UACV,CAAC;AAAA,QACH,CAAC;AAAA,MACH,GAAG;AAAA,IACL;AAAA,EACF;AAEA,QAAM,QAAQ,IAAI,QAAQ;AAC5B;AAEA,IAAO,0BAAQ;;;AC7Ef,IAAAC,oBAAiB;AAEjB,IAAAC,mBAAe;AAIf,IAAM,WAAW,kBAAU,EAAE,YAAY;AAElC,IAAM,kBAAkB,SAAS,WAAW,GAAG,IAAI,WAAW,kBAAAC,QAAK,KAAK,QAAQ,IAAI,GAAG,QAAQ;AAC/F,IAAM,uBAAuB,kBAAAA,QAAK,KAAK,iBAAiB,oBAAoB;AAE5E,IAAM,iBAAiB,OAAOC,YAAW,oBAAoB;AAClE,QAAM,iBAAAC,QAAG,OAAOD,SAAQ;AAC1B;AAOO,IAAM,oBAAoB,CAAC,WAAW,yBAAsC;AACjF,MAAI;AACF,WAAO,KAAK,MAAM,iBAAAC,QAAG,aAAa,UAAU,OAAO,CAAC;AAAA,EACtD,SAAS,GAAG;AACV,WAAO,CAAC;AAAA,EACV;AACF;AAEO,IAAM,qBAAqB,CAAC,aAA0B,WAAW,yBAAyB;AAC/F,mBAAAA,QAAG,cAAc,UAAU,KAAK,UAAU,WAAW,GAAG,OAAO;AACjE;;;AC9BA,yBAAmB;AACnB,0BAAwB;AAExB,IAAM,MAAM,IAAI,oBAAAC,QAAY,UAAU;AAAA,EACpC,QAAQ,0BAA0B,mBAAAC,QAAO,KAAK,OAAO,CAAC;AAAA,EACtD,iBAAiB;AAAA,EACjB,mBAAmB;AAAA,EACnB,YAAY;AAAA,EACZ,gBAAgB;AAClB,CAAC;AAEM,IAAM,sBAAsB,CAAC,UAAkB;AACpD,MAAI,MAAM,OAAO,CAAC;AACpB;AAEO,IAAM,0BAA0B,CAAC,cAAuB;AAC7D,MAAI,UAAU,SAAS;AACzB;;;ACjBA,oBAAqB;AAIrB,IAAM,cAAc,CAAC,cACnB,cAAAC,SAAS,OAAO,CAAC,GAAG,MAAM,EAAE,WAAW,EAAE,UAAU,EAAE,UAAU,EAAE,SAAS,EAAE,cAAc,EAAE,SAAS;AAEvG,IAAO,sBAAQ;;;AToCR,IAAM,oBAAuC,OAAO;AAAA,EACzD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,UAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,yBAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAM;AACJ,MAAI,uBAAe,SAAS,GAAG;AAC7B,QAAI;AACF,YAAM,WAAW,kBAAAC,QAAK,KAAK,SAAS,MAAM;AAC1C,YAAM,iBAAAC,QAAG,WAAW,QAAQ;AAE5B,YAAM,aAAa,kBAAAD,QAAK,KAAKF,WAAU,MAAM;AAC7C,YAAM,iBAAAG,QAAG,WAAW,UAAU;AAG9B,UAAI,CAAC,SAAS;AACZ,cAAM,uBAAuB,YAAY,UAAU,CAAC,eAAe,WAAW,WAAW,MAAM;AAC/F,cAAM,WAAO,+BAAW,QAAQ,EAAE,OAAO,WAAW,EAAE,OAAO,KAAK;AAElE,YAAI,yBAAyB,IAAI;AAC/B,sBAAY,KAAK,EAAE,QAAQ,KAAK,CAAC;AAAA,QACnC,OAAO;AACL,gBAAM,oBAAoB,YAAY,oBAAoB;AAC1D,cAAI,mBAAmB,SAAS,MAAM;AACpC,kBAAM,iBAAAA,QAAG,KAAK,YAAY,QAAQ;AAClC,6BAAiB;AACjB,YAAAF,yBAAwB;AACxB;AAAA,UACF;AACA,cAAI,sBAAsB,QAAW;AACnC,8BAAkB,OAAO;AAAA,UAC3B;AAAA,QACF;AAAA,MACF;AAEA,YAAM,YAAQ,aAAAG,SAAM,aAAa,EAAE,gBAAgB,MAAM,UAAU,KAAK,CAAC;AAEzE,YAAM,OAAO,EAAE,OAAO,EAAE,OAAO,oBAAoB,KAAK,CAAC;AAEzD,cAAQ,WAAW;AAAA,QACjB,KAAK,QAAQ;AACX,gBAAM,OAAO,MAAM,MAAM,KAAK,EAAE,SAAS,GAAG,cAAc,IAAI,CAAC;AAC/D,gBAAM,KAAK,OAAO,UAAU;AAC5B,gBAAM,KAAK,OAAO,QAAQ;AAC1B;AAAA,QACF;AAAA,QACA,KAAK,OAAO;AACV,gBAAM,MAAM,MAAM,MAAM,KAAK,EAAE,SAAS,GAAG,cAAc,IAAI,CAAC;AAC9D,gBAAM,IAAI,OAAO,UAAU;AAC3B,gBAAM,IAAI,OAAO,QAAQ;AACzB;AAAA,QACF;AAAA,QACA,KAAK,OAAO;AACV,gBAAM,MAAM,MAAM,MAAM,IAAI,EAAE,SAAS,GAAG,cAAc,IAAI,CAAC;AAC7D,gBAAM,IAAI,OAAO,UAAU;AAC3B,gBAAM,IAAI,OAAO,QAAQ;AACzB;AAAA,QACF;AAAA,QACA,KAAK,QAAQ;AACX,gBAAM,OAAO,MAAM,KAAK,EAAE,SAAS,GAAG,cAAc,KAAK,CAAC;AAC1D,gBAAM,KAAK,OAAO,UAAU;AAC5B,gBAAM,KAAK,OAAO,QAAQ;AAC1B;AAAA,QACF;AAAA,QACA,KAAK,QAAQ;AACX,gBAAM,OAAO,MAAM,KAAK,EAAE,SAAS,GAAG,cAAc,KAAK,CAAC;AAC1D,gBAAM,KAAK,OAAO,UAAU;AAC5B,gBAAM,KAAK,OAAO,QAAQ;AAC1B;AAAA,QACF;AAAA,MACF;AAEA,0BAAoB;AAAA,IACtB,SAAS,OAAO;AACd,cAAQ,KAAK,KAAK;AAClB,uBAAiB;AAAA,IACnB,UAAE;AACA,MAAAH,yBAAwB;AAAA,IAC1B;AAAA,EACF,OAAO;AACL,QAAI;AACF,YAAM,WAAW,kBAAAC,QAAK,KAAK,SAAS,MAAM;AAC1C,YAAM,iBAAAC,QAAG,WAAW,QAAQ;AAE5B,YAAM,iBAAAA,QAAG,KAAK,kBAAkB,QAAQ;AAExC,oBAAc,SAAS,wBAAwB,gBAAgB;AAAA,IACjE,SAAS,OAAO;AACd,cAAQ,KAAK,KAAK;AAClB,uBAAiB;AAAA,IACnB,UAAE;AACA,MAAAF,yBAAwB;AAAA,IAC1B;AAAA,EACF;AACF;AAEA,IAAM,MAAM,QAAQ,IAAI;AAUjB,IAAM,iBAAiB,OAAO;AAAA,EACnC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,QAAQ;AACV,MAA2B;AACzB,QAAM,UAAU,OAAO,SAAS,UAAU,MAAM,kBAAAC,QAAK,QAAQ,KAAK,OAAO,UAAU,KAAK;AACxF,QAAM,SAAS,OAAO,SAAS,UAAU,MAAM;AAE/C,MAAI,WAAqB,CAAC;AAC1B,MAAI;AACF,QAAI,iBAAAC,QAAG,WAAW,gBAAgB,GAAG;AACnC,iBAAW,oBAAY,wBAAgB,MAAM,iBAAAA,QAAG,SAAS,kBAAkB,OAAO,CAAC,CAAC;AAAA,IACtF;AAAA,EACF,SAAS,OAAO;AACd,UAAM,MAAM,OAAO,UAAU,WAAW,QAAQ,mBAAmB;AAAA,EACrE;AAGA,QAAM,WAAW,CAAC,GAAG,gBAAgB,YAAY,GAAG,gBAAgB,WAAW;AAG/E,QAAM,eACJ,OAAO,iBAAiB,SACpB,CAAC,IACD,OAAO,OAAO,iBAAiB,aAC7B,MAAM,OAAO,aAAa,IAC1B,OAAO;AACf,MAAI,aAAa,SAAS,GAAG;AAC3B,UAAM,kBAAkB,oBAAI,IAAY;AAExC,eAAW,OAAO,cAAc;AAC9B,sBAAgB,IAAI,GAAG;AAAA,IACzB;AAEA,eAAW,SAAS;AAAA,MAClB,MAAM,KAAK,eAAe,EACvB;AAAA,QAAI,CAAC,QACJ,SAAS,IAAI,CAAC,SAAS;AACrB,iBAAO,wBAAgB;AAAA,YACrB,KAAK;AAAA,YACL,OAAO;AAAA,YACP;AAAA,UACF,CAAC,EAAE,IAAI,CAAC,EAAE,QAAQ,WAAW,kBAAkB,MAAM;AACnD,kBAAM,oBAAoB,GACxB,OAAO,mBACH,OAAO,iBAAiB,QAAQ,OAAO,EAAE,EAAE,QAAQ,OAAO,EAAE,IAC5D,oBACN;AAEA,kBAAM,OAAyB;AAAA,cAC7B;AAAA,cACA,KAAK,IAAI,OAAO,SAAS,UAAU,kBAAkB,QAAQ,UAAU,OAAO,IAAI,iBAAiB,QAAI;AAAA,gBACrG;AAAA,cACF,EACG;AAAA,gBACC,IACG,QAAQ,gBAAgB,EAAE,EAC1B,MAAM,GAAG,EACT,MAAM,CAAC,EACP,KAAK,GAAG;AAAA,cACb,EACC,OAAO,KAAK,CAAC,IAAI,iBAAiB;AAAA,cACrC,OAAO;AAAA,cACP;AAAA,cACA,aAAa;AAAA,YACf;AAEA,mBAAO;AAAA,UACT,CAAC;AAAA,QACH,CAAC;AAAA,MACH,EACC,KAAK,CAAC;AAAA,IACX;AAAA,EACF;AACA,MAAI,SAAS,KAAK,CAAC,EAAE,YAAY,MAAM,gBAAgB,MAAS,GAAG;AACjE,UAAM,wBAAyB;AAAA,MAC7B;AAAA,MACA;AAAA,MACA;AAAA,MACA,4BAA4B,OAAO;AAAA,IACrC,CAAC;AAAA,EACH;AAEA,QAAM,YAAY,kBAAAD,QAAK,QAAQ,KAAK,QAAQ;AAC5C,MAAI,iBAAAC,QAAG,WAAW,SAAS,GAAG;AAC5B,QAAI,CAAC,OAAO;AACV,cAAQ,IAAI,0CAA0C;AAAA,IACxD;AACA,UAAM,cAAc,OAAO,cAAc,OAAO,YAAY,IAAI,CAAC,MAAM,kBAAAD,QAAK,KAAK,WAAW,CAAC,CAAC,IAAI,CAAC;AAEnG,UAAM,iBAAiB,UAAM,yBAAAG,SAAiB,SAAS;AACvD,UAAM,kBAAkB,eACrB,OAAO,CAAC,SAAS;AAChB,YAAM,MAAM,kBAAAH,QAAK,QAAQ,IAAI,EAAE,YAAY;AAC3C,aACE,QAAQ,UAAU,QAAQ,UAAU,QAAQ,WAAW,QAAQ,WAAW,QAAQ,WAAW,QAAQ;AAAA,IAEzG,CAAC,EACA,OAAO,CAAC,SAAS,CAAC,YAAY,SAAS,IAAI,CAAC;AAC/C,eAAW,SAAS;AAAA,MAClB,gBACG;AAAA,QAAI,CAAC,SACJ,SAAS,IAAI,CAAC,SAAS;AACrB,gBAAM,aAAa,OAAO,SAAS,UAAU,UAAU,QAAQ,WAAW,EAAE,IAAI;AAChF,gBAAM,MAAM,KAAK,QAAQ,YAAY,EAAE;AACvC,iBAAO,wBAAgB;AAAA,YACrB;AAAA,YACA,OAAO;AAAA,YACP;AAAA,UACF,CAAC,EAAE,IAAI,CAAC,EAAE,QAAQ,UAAU,MAAM;AAChC,kBAAM,OAAyB;AAAA,cAC7B;AAAA,cACA;AAAA,cACA,OAAO;AAAA,cACP;AAAA,YACF;AAEA,mBAAO;AAAA,UACT,CAAC;AAAA,QACH,CAAC;AAAA,MACH,EACC,KAAK,CAAC;AAAA,IACX;AAAA,EACF;AAEA,MAAI,CAAC,OAAO;AACV,YAAQ,IAAI,0BAA0B;AACtC,wBAAoB,SAAS,MAAM;AAAA,EACrC;AAEA,MAAI,cAA2B,CAAC;AAEhC,MAAI,CAAC,SAAS;AACZ,UAAM,eAAe;AACrB,kBAAc,kBAAkB;AAAA,EAClC;AAEA,MAAI,gBAAgB;AACpB,MAAI,mBAAmB;AACvB,MAAI,gBAAgB;AACpB,QAAM,sBAAsB,oBAAI,IAAY,CAAC,CAAC;AAE9C,QAAM,mBAAmB,MAAM;AAC7B,qBAAiB;AAAA,EACnB;AACA,QAAM,sBAAsB,MAAM;AAChC,wBAAoB;AAAA,EACtB;AACA,QAAM,mBAAmB,MAAM;AAC7B,qBAAiB;AAAA,EACnB;AACA,QAAM,0BAA0B,CAAC,UAAkB,oBAAoB,IAAI,KAAK;AAEhF,QAAM,SAA0D,CAAC;AACjE,aAAW,QAAQ,UAAU;AAC3B,UAAM,EAAE,KAAK,GAAG,KAAK,IAAI;AACzB,QAAI,OAAO,QAAQ;AACjB,aAAO,GAAG,GAAG,KAAK,IAAI;AAAA,IACxB,OAAO;AACL,aAAO,GAAG,IAAI,CAAC,IAAI;AAAA,IACrB;AAAA,EACF;AAEA,QAAM,WAA4B,CAAC;AAEnC,aAAW,OAAO,QAAQ;AACxB,UAAM,QAAQ,OAAO,GAAG;AAExB,QAAI,UAAU,UAAa,MAAM,WAAW,EAAG;AAE/C,UAAM,mBAAmB,kBAAAA,QAAK,KAAK,QAAQ,OAAO,SAAS,UAAU,IAAI,QAAQ,YAAY,QAAQ,IAAI,GAAG;AAC5G,UAAM,cAAc,MAAM,iBAAAC,QAAG,SAAS,gBAAgB;AAEtD,eAAW,QAAQ,OAAO;AACxB,WAAK,SAAS,OAAO,SAAS,UAAU,KAAK,OAAO,QAAQ,YAAY,QAAQ,IAAI,KAAK;AAEzF,eAAS;AAAA,QACP,kBAAkB;AAAA,UAChB;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,UAAU;AAAA,UACV;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,yBAAyB,QAAQ,MAAM,SAAY;AAAA,UACnD;AAAA,UACA,SAAS,OAAO,WAAW;AAAA,UAC3B,cAAc,OAAO,gBAAgB,CAAC;AAAA,UACtC,GAAG;AAAA,QACL,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAEA,QAAM,QAAQ,IAAI,QAAQ;AAE1B,MAAI,CAAC,SAAS;AACZ,uBAAmB,WAAW;AAAA,EAChC;AAEA,MAAI,CAAC,OAAO;AAEV,YAAQ,IAAI,iBAAiB,aAAa,sBAAsB,gBAAgB,mBAAmB,aAAa,EAAE;AAElH,QAAI,oBAAoB,SAAS,GAAG;AAElC,cAAQ;AAAA,QACN;AAAA,QACA,MAAM,KAAK,mBAAmB,EAAE,KAAK,IAAI;AAAA,MAC3C;AAAA,IACF;AAEA,YAAQ,IAAI,oBAAAG,QAAO,KAAK,QAAQ,4BAA4B,CAAC;AAAA,EAC/D;AACF;AAIO,IAAM,MAAW,OAAO,EAAE,UAAU,MAAM,MAAM;AAErD,UAAQ,IAAI,oBAAAA,QAAO,KAAK,QAAQ,iDAAiD,CAAC;AAElF,QAAM,SAAS,kBAAU;AACzB,QAAM,mBAAmB,kBAAAJ,QAAK,QAAQ,KAAK,gDAAgD;AAE3F,QAAM,aAAa,UAAM,cAAAK,SAAW,yCAAwB,GAAG;AAE/D,QAAM,eAAe,EAAE,kBAAkB,SAAS,QAAQ,iBAAiB,WAAW,OAAO,CAAC;AAChG;","names":["import_node_path","import_ansi_colors","import_fs_extra","path","extension","path","fs","import_node_path","import_fs_extra","path","cacheDir","fs","cliProgress","colors","uniqWith","cacheDir","cliProgressBarIncrement","path","fs","sharp","recursiveReadDir","colors","loadConfig"]}