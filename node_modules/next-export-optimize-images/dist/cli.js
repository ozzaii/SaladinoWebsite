"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/cli/index.ts
var cli_exports = {};
__export(cli_exports, {
  getOptimizeResult: () => getOptimizeResult,
  optimizeImages: () => optimizeImages,
  run: () => run
});
module.exports = __toCommonJS(cli_exports);
var import_node_crypto = require("crypto");
var import_node_path3 = __toESM(require("path"));
var import_ansi_colors2 = __toESM(require("ansi-colors"));
var import_fs_extra3 = __toESM(require("fs-extra"));
var import_constants = require("next/constants");
var import_config = __toESM(require("next/dist/server/config"));
var import_recursive_readdir = __toESM(require("recursive-readdir"));
var import_sharp = __toESM(require("sharp"));

// src/utils/formatValidate.ts
var formats = ["jpeg", "jpg", "png", "webp", "avif"];
var formatValidate = (format) => formats.some((allowedFormat) => allowedFormat === format);
var formatValidate_default = formatValidate;

// src/utils/buildOutputInfo.ts
var defaultImageParser = (src) => {
  const path4 = src.split(/\.([^.]*$)/)[0];
  const extension = (src.split(/\.([^.]*$)/)[1] || "").split("?")[0];
  if (!path4 || !extension) {
    throw new Error(`Invalid path or no file extension: ${src}`);
  }
  let pathWithoutName = path4.split("/").slice(0, -1).join("/");
  const name = path4.split("/").slice(-1).toString();
  if (src.startsWith("http")) {
    pathWithoutName = pathWithoutName.replace(/^https?:\/\//, "").split("/").slice(1).join("/");
  }
  return {
    pathWithoutName,
    name,
    extension
  };
};
var buildOutputInfo = ({ src: _src, width, config }) => {
  let src = _src;
  if (config.basePath !== void 0) {
    src = _src.replace(config.basePath, "");
  }
  const parsedImageInformation = config.sourceImageParser ? config.sourceImageParser({ src, defaultParser: defaultImageParser }) : defaultImageParser(src);
  let { extension } = parsedImageInformation;
  const { pathWithoutName, name, extension: originalExtension } = parsedImageInformation;
  if (config.convertFormat !== void 0) {
    const convertArray = config.convertFormat.find(([beforeConvert]) => beforeConvert === extension);
    if (convertArray !== void 0) {
      if (!formatValidate_default(convertArray[0]))
        throw Error(`Unauthorized format specified in \`configFormat\`. beforeConvert: ${convertArray[0]}`);
      if (!formatValidate_default(convertArray[1]))
        throw Error(`Unauthorized format specified in \`configFormat\`. afterConvert: ${convertArray[1]}`);
      extension = convertArray[1];
    }
  }
  const outputDir = `/${config.imageDir ? config.imageDir.replace(/^\//, "").replace(/\/$/, "") : "_next/static/chunks/images"}`;
  const extensions = [.../* @__PURE__ */ new Set([...config.generateFormats ?? ["webp"], extension])];
  return extensions.map((extension2, index) => {
    if (extensions.length !== index + 1 && !formatValidate_default(extension2))
      throw Error(`Unauthorized extension specified in \`generateFormats\`: ${extension2}`);
    const filename = config.filenameGenerator !== void 0 ? config.filenameGenerator({ path: pathWithoutName, name, width, extension: extension2 }) : `${pathWithoutName}/${name}_${width}.${extension2}`;
    const output = `${outputDir}/${filename.replace(/^\//, "")}`;
    return { output, src, extension: extension2, originalExtension };
  });
};
var buildOutputInfo_default = buildOutputInfo;

// src/utils/getConfig.ts
var getConfig = () => {
  const config = require("next-export-optimize-images/export-images.config.js");
  return {
    ...config,
    filenameGenerator: config.filenameGenerator ? Function(`"use strict";return (${config.filenameGenerator})`)() : void 0,
    sourceImageParser: config.sourceImageParser ? Function(`"use strict";return (${config.sourceImageParser})`)() : void 0
  };
};
var getConfig_default = getConfig;

// src/utils/parseNdJSON.ts
var parseNdJSON = (ndjson) => ndjson.trim().split(/\n/g).map((line) => JSON.parse(line));
var parseNdJSON_default = parseNdJSON;

// src/utils/processManifest.ts
var processManifest = (manifestJson) => parseNdJSON_default(manifestJson);
var processManifest_default = processManifest;

// src/cli/external-images/index.ts
var import_node_path = __toESM(require("path"));
var import_node_stream = require("stream");
var import_fs_extra = __toESM(require("fs-extra"));
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var externalImagesDownloader = async ({
  terse = false,
  manifest,
  destDir,
  remoteImagesDownloadsDelay
}) => {
  if (!terse) {
    console.log("\n- Download external images -");
  }
  const promises = [];
  const downloadedImages = [];
  for (const { src, externalUrl } of manifest) {
    if (externalUrl === void 0) continue;
    if (downloadedImages.some((image) => image === externalUrl)) continue;
    if (remoteImagesDownloadsDelay) {
      await sleep(remoteImagesDownloadsDelay);
    }
    promises.push(
      (async () => {
        downloadedImages.push(externalUrl);
        const outputPath = import_node_path.default.join(destDir, src);
        await import_fs_extra.default.ensureFile(outputPath);
        const body = await fetch(externalUrl).then((response) => response.body).catch((e) => {
          throw new Error(`Failed to download \`${externalUrl}\`: ${e}`);
        });
        if (body === null) {
          throw new Error(`Failed to download \`${externalUrl}\`: reason: body is null`);
        }
        const readableNodeStream = import_node_stream.Stream.Readable.fromWeb(body);
        const fileStream = import_fs_extra.default.createWriteStream(outputPath);
        return new Promise((resolve, reject) => {
          readableNodeStream.pipe(fileStream);
          readableNodeStream.on("error", reject);
          fileStream.on("finish", () => {
            if (!terse) {
              console.log(`\`${externalUrl}\` has been downloaded.`);
            }
            resolve();
          });
        });
      })()
    );
  }
  await Promise.all(promises);
};
var external_images_default = externalImagesDownloader;

// src/cli/utils/cache.ts
var import_node_path2 = __toESM(require("path"));
var import_fs_extra2 = __toESM(require("fs-extra"));
var cacheDir = getConfig_default().cacheDir || "node_modules/.cache/next-export-optimize-images";
var defaultCacheDir = cacheDir.startsWith("/") ? cacheDir : import_node_path2.default.join(process.cwd(), cacheDir);
var defaultCacheFilePath = import_node_path2.default.join(defaultCacheDir, "cached-images.json");
var createCacheDir = async (cacheDir2 = defaultCacheDir) => {
  await import_fs_extra2.default.mkdirp(cacheDir2);
};
var readCacheManifest = (filePath = defaultCacheFilePath) => {
  try {
    return JSON.parse(import_fs_extra2.default.readFileSync(filePath, "utf-8"));
  } catch (_) {
    return [];
  }
};
var writeCacheManifest = (cacheImages, filePath = defaultCacheFilePath) => {
  import_fs_extra2.default.writeFileSync(filePath, JSON.stringify(cacheImages), "utf-8");
};

// src/cli/utils/cliProgressBar.ts
var import_ansi_colors = __toESM(require("ansi-colors"));
var import_cli_progress = __toESM(require("cli-progress"));
var bar = new import_cli_progress.default.SingleBar({
  format: `Optimization progress |${import_ansi_colors.default.cyan("{bar}")}| {percentage}% || {value}/{total} Chunks`,
  barCompleteChar: "\u2588",
  barIncompleteChar: "\u2591",
  hideCursor: true,
  stopOnComplete: true
});
var cliProgressBarStart = (total) => {
  bar.start(total, 0);
};
var cliProgressBarIncrement = (addNumber) => {
  bar.increment(addNumber);
};

// src/cli/utils/uniqueItems.ts
var import_lodash = __toESM(require("lodash.uniqwith"));
var uniqueItems = (items) => (0, import_lodash.default)(items, (a, b) => a.output === b.output && a.width === b.width && a.extension === b.extension);
var uniqueItems_default = uniqueItems;

// src/cli/index.ts
var getOptimizeResult = async ({
  imageBuffer,
  destDir,
  noCache,
  cacheImages,
  cacheDir: cacheDir2,
  cacheMeasurement,
  nonCacheMeasurement,
  errorMeasurement,
  pushInvalidFormatAssets,
  cliProgressBarIncrement: cliProgressBarIncrement2,
  originalFilePath,
  quality,
  sharpOptions,
  output,
  width,
  extension
}) => {
  if (formatValidate_default(extension)) {
    try {
      const filePath = import_node_path3.default.join(destDir, output);
      await import_fs_extra3.default.ensureFile(filePath);
      const outputPath = import_node_path3.default.join(cacheDir2, output);
      await import_fs_extra3.default.ensureFile(outputPath);
      if (!noCache) {
        const cacheImagesFindIndex = cacheImages.findIndex((cacheImage) => cacheImage.output === output);
        const hash = (0, import_node_crypto.createHash)("sha256").update(imageBuffer).digest("hex");
        if (cacheImagesFindIndex === -1) {
          cacheImages.push({ output, hash });
        } else {
          const currentCacheImage = cacheImages[cacheImagesFindIndex];
          if (currentCacheImage?.hash === hash) {
            await import_fs_extra3.default.copy(outputPath, filePath);
            cacheMeasurement();
            cliProgressBarIncrement2();
            return;
          }
          if (currentCacheImage !== void 0) {
            currentCacheImage.hash = hash;
          }
        }
      }
      const image = (0, import_sharp.default)(imageBuffer, { sequentialRead: true, animated: true });
      image.rotate().resize({ width, withoutEnlargement: true });
      switch (extension) {
        case "jpeg": {
          const jpeg = await image.jpeg({ quality, ...sharpOptions?.jpg });
          await jpeg.toFile(outputPath);
          await jpeg.toFile(filePath);
          break;
        }
        case "jpg": {
          const jpg = await image.jpeg({ quality, ...sharpOptions?.jpg });
          await jpg.toFile(outputPath);
          await jpg.toFile(filePath);
          break;
        }
        case "png": {
          const png = await image.png({ quality, ...sharpOptions?.png });
          await png.toFile(outputPath);
          await png.toFile(filePath);
          break;
        }
        case "webp": {
          const webp = image.webp({ quality, ...sharpOptions?.webp });
          await webp.toFile(outputPath);
          await webp.toFile(filePath);
          break;
        }
        case "avif": {
          const avif = image.avif({ quality, ...sharpOptions?.avif });
          await avif.toFile(outputPath);
          await avif.toFile(filePath);
          break;
        }
      }
      nonCacheMeasurement();
    } catch (error) {
      console.warn(error);
      errorMeasurement();
    } finally {
      cliProgressBarIncrement2();
    }
  } else {
    try {
      const filePath = import_node_path3.default.join(destDir, output);
      await import_fs_extra3.default.ensureFile(filePath);
      await import_fs_extra3.default.copy(originalFilePath, filePath);
      extension !== "svg" && pushInvalidFormatAssets(originalFilePath);
    } catch (error) {
      console.warn(error);
      errorMeasurement();
    } finally {
      cliProgressBarIncrement2();
    }
  }
};
var cwd = process.cwd();
var optimizeImages = async ({
  manifestJsonPath,
  noCache,
  config,
  nextImageConfig,
  terse = false
}) => {
  const destDir = config.mode === "build" ? cwd : import_node_path3.default.resolve(cwd, config.outDir ?? "out");
  const srcDir = config.mode === "build" ? cwd : destDir;
  let manifest = [];
  try {
    if (import_fs_extra3.default.existsSync(manifestJsonPath)) {
      manifest = uniqueItems_default(processManifest_default(await import_fs_extra3.default.readFile(manifestJsonPath, "utf-8")));
    }
  } catch (error) {
    throw Error(typeof error === "string" ? error : "Unexpected error.");
  }
  const allSizes = [...nextImageConfig.imageSizes, ...nextImageConfig.deviceSizes];
  const remoteImages = config.remoteImages === void 0 ? [] : typeof config.remoteImages === "function" ? await config.remoteImages() : config.remoteImages;
  if (remoteImages.length > 0) {
    const remoteImageList = /* @__PURE__ */ new Set();
    for (const url of remoteImages) {
      remoteImageList.add(url);
    }
    manifest = manifest.concat(
      Array.from(remoteImageList).map(
        (url) => allSizes.map((size) => {
          return buildOutputInfo_default({
            src: url,
            width: size,
            config
          }).map(({ output, extension, originalExtension }) => {
            const externalOutputDir = `${config.externalImageDir ? config.externalImageDir.replace(/^\//, "").replace(/\/$/, "") : "_next/static/media"}`;
            const json = {
              output,
              src: `/${config.mode === "build" ? externalOutputDir.replace(/^_next/, ".next") : externalOutputDir}/${(0, import_node_crypto.createHash)(
                "sha256"
              ).update(
                url.replace(/^https?:\/\//, "").split("/").slice(1).join("/")
              ).digest("hex")}.${originalExtension}`,
              width: size,
              extension,
              externalUrl: url
            };
            return json;
          });
        })
      ).flat(2)
    );
  }
  if (manifest.some(({ externalUrl }) => externalUrl !== void 0)) {
    await external_images_default({
      terse,
      manifest,
      destDir,
      remoteImagesDownloadsDelay: config.remoteImagesDownloadsDelay
    });
  }
  const publicDir = import_node_path3.default.resolve(cwd, "public");
  if (import_fs_extra3.default.existsSync(publicDir)) {
    if (!terse) {
      console.log("\n- Collect images in public directory -");
    }
    const ignorePaths = config.ignorePaths ? config.ignorePaths.map((p) => import_node_path3.default.join(publicDir, p)) : [];
    const publicDirFiles = await (0, import_recursive_readdir.default)(publicDir);
    const publicDirImages = publicDirFiles.filter((file) => {
      const ext = import_node_path3.default.extname(file).toLowerCase();
      return ext === ".png" || ext === ".jpg" || ext === ".jpeg" || ext === ".webp" || ext === ".avif" || ext === ".gif";
    }).filter((file) => !ignorePaths.includes(file));
    manifest = manifest.concat(
      publicDirImages.map(
        (file) => allSizes.map((size) => {
          const ignorePath = config.mode === "build" ? publicDir.replace(/public$/, "") : publicDir;
          const src = file.replace(ignorePath, "");
          return buildOutputInfo_default({
            src,
            width: size,
            config
          }).map(({ output, extension }) => {
            const json = {
              output,
              src,
              width: size,
              extension
            };
            return json;
          });
        })
      ).flat(2)
    );
  }
  if (!terse) {
    console.log("\n- Image Optimization -");
    cliProgressBarStart(manifest.length);
  }
  let cacheImages = [];
  if (!noCache) {
    await createCacheDir();
    cacheImages = readCacheManifest();
  }
  let measuredCache = 0;
  let measuredNonCache = 0;
  let measuredError = 0;
  const invalidFormatAssets = /* @__PURE__ */ new Set([]);
  const cacheMeasurement = () => {
    measuredCache += 1;
  };
  const nonCacheMeasurement = () => {
    measuredNonCache += 1;
  };
  const errorMeasurement = () => {
    measuredError += 1;
  };
  const pushInvalidFormatAssets = (asset) => invalidFormatAssets.add(asset);
  const srcMap = {};
  for (const item of manifest) {
    const { src, ...rest } = item;
    if (src in srcMap) {
      srcMap[src]?.push(rest);
    } else {
      srcMap[src] = [rest];
    }
  }
  const promises = [];
  for (const key in srcMap) {
    const items = srcMap[key];
    if (items === void 0 || items.length === 0) continue;
    const originalFilePath = import_node_path3.default.join(srcDir, config.mode === "build" ? key.replace(/^\/_next/, "/.next") : key);
    const imageBuffer = await import_fs_extra3.default.readFile(originalFilePath);
    for (const item of items) {
      item.output = config.mode === "build" ? item.output.replace(/^\/_next/, "/.next") : item.output;
      promises.push(
        getOptimizeResult({
          imageBuffer,
          destDir,
          noCache,
          cacheImages,
          cacheDir: defaultCacheDir,
          cacheMeasurement,
          nonCacheMeasurement,
          errorMeasurement,
          pushInvalidFormatAssets,
          cliProgressBarIncrement: terse ? () => void 0 : cliProgressBarIncrement,
          originalFilePath,
          quality: config.quality ?? 75,
          sharpOptions: config.sharpOptions ?? {},
          ...item
        })
      );
    }
  }
  await Promise.all(promises);
  if (!noCache) {
    writeCacheManifest(cacheImages);
  }
  if (!terse) {
    console.log(`Cache assets: ${measuredCache}, NonCache assets: ${measuredNonCache}, Error assets: ${measuredError}`);
    if (invalidFormatAssets.size !== 0) {
      console.log(
        "\nThe following images are in a non-optimized format and a simple copy was applied.\n",
        Array.from(invalidFormatAssets).join("\n")
      );
    }
    console.log(import_ansi_colors2.default.bold.magenta("\nSuccessful optimization!"));
  }
};
var run = async ({ noCache = false }) => {
  console.log(import_ansi_colors2.default.bold.magenta("\nnext-export-optimize-images: Optimize images."));
  const config = getConfig_default();
  const manifestJsonPath = import_node_path3.default.resolve(cwd, ".next/next-export-optimize-images-list.nd.json");
  const nextConfig = await (0, import_config.default)(import_constants.PHASE_PRODUCTION_BUILD, cwd);
  await optimizeImages({ manifestJsonPath, noCache, config, nextImageConfig: nextConfig.images });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getOptimizeResult,
  optimizeImages,
  run
});
//# sourceMappingURL=cli.js.map